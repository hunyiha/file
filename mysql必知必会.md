# mysql必知必会

## 1.了解数据库和表

show database;返回可用数据库的一个列表。

show tables;返回当前选择的数据库内可用表的列表。

```txt
show columns from customers;

describe customers;
对每个字段返回一行，行中包含字段名、数据
类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id
的auto_increment）。
```

## 2.检索数据

```
一般，除非你确实需要表中的每个列，否则最
好别使用*通配符。虽然使用通配符可能会使你自己省事，不
用明确列出所需列，但检索不需要的列通常会降低检索和应
用程序的性能。
```

**1）检索不同的行**

DISTINCT关键字应用于所有列而
不仅是前置它的列。如果给出SELECT DISTINCT vend_id,
prod_price，除非指定的两个列都不同，否则所有行都将被
检索出来。

**2）限制结果**

为了返回第一行或前几行，可使用LIMIT子句。

行0 检索出来的第一行为行0而不是行1。因此，LIMIT 1, 1
将检索出第二行而不是第一行。

**3）使用完全限定的表名**

select products.prod_name from products;

select products.prod_name from crashcourse.products;

## 3.过滤数据

**1）WHERE子句操作符**
操 作 符 说 明
= 等于
<> 不等于
!= 不等于
< 小于
<= 小于等于

》大于

》=大于等于

between 在指定的两个值之间

**2）MySQL在执行匹配时默认不区分大小写，**

**3）BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。**

**4）IS NULL子句**

ELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。
这个WHERE子句就是IS NULL子句。

**5）计算次序**

| select prod_name,prod_price,vend_id from products where vend_id =1002 or vend_id =1003 and prod_price >=10;      当SQL看到上述WHERE子句时，它理解为由供应商1003制造的任何价格为10美元（含）以上的产品，或者由供应商1002制造的任何产品，而不管其价格如何。 |
| ------------------------------------------------------------ |
| select prod_name,prod_price,vend_id from products where (vend_id =1002 or vend_id =1003) and prod_price >=10;   选择由供应商1002或1003制造的且价格都在10美元（含）以上的任何产品 |
| 上面两条语句执行结果不同                                     |

在WHERE子句中使用圆括号 任何时候使用具有AND和OR操作
符的WHERE子句，都应该使用圆括号明确地分组操作符。不要
过分依赖默认计算次序，即使它确实是你想要的东西也是如
此。使用圆括号没有什么坏处，它能消除歧义。

**6）not 操作符**

MySQL中的NOT MySQL支持使用NOT对IN、BETWEEN和
EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。

## **4.用通配符进行过滤**

通配符（wildcard） 用来匹配值的一部分的特殊字符。

搜索模式（search pattern）① 由字面值、通配符或两者组合构成的搜索条件。

```txt
正如所见，MySQL的通配符很有用。但这种功能是有代价的：通配
符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一
些使用通配符要记住的技巧。
*不要过度使用通配符。如果其他操作符能达到相同的目的，应该
使用其他操作符。
*在确实需要使用通配符时，除非绝对有必要，否则不要把它们用
在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起
来是最慢的。
*仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。
```

## 5.正则表达式

它告诉MySQL：REGEXP后所跟的东西作
为正则表达式处理。

select prod_id,prod_name from products where prod_name regexp '1000';

为搜索两个串之一（或者为这个串，或者为另一个串），使用|

[]是另一种形式的OR语句。

字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。



匹配特殊字符

\\\\\



匹配字符类

[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntrl:] ASCII控制字符（ASCII 0到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[:print:]相同，但不包括空格
[:lower:] 任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）



匹配多个实例

表9-3 重复元字符
元 字 符 说 明
* 0个或多个匹配
+ 1个或多个匹配（等于{1,}）
? 0个或1个匹配（等于{0,1}）
{n} 指定数目的匹配
{n,} 不少于指定数目的匹配
{n,m} 匹配数目的范围（m不超过255）



**定位符**

表9-4 定位元字符
元 字 符 说 明
^ 文本的开始
$ 文本的结尾
[[:<:]] 词的开始
[[:>:]] 词的结尾



select prod_name from products where prod_name regexp '^[0-9\\.]';

^的双重用途 ^有两种用法。在集合中（用[和]定义），用它
来否定该集合，否则，用来指串的开始处





简单的正则表达式测试 可以在不使用数据库表的情况下用
SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配）
或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试
验它们。相应的语法如下：
这个例子显然将返回0（因为文本hello中没有数字）。